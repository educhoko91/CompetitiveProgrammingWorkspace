<?xml version="1.0" encoding="UTF-8" standalone="no"?><templates><template autoinsert="true" context="java" deleted="false" description="Segment Tree" enabled="true" name="segtree">	/*&#13;
	 * &#13;
	 * ****************&#13;
	 * * SEGMENT TREE *&#13;
	 * ****************&#13;
	 * &#13;
	 * TEMPLATE: segtree&#13;
	 * &#13;
	 */&#13;
	&#13;
	/* el tamano del tree debe ser 4 veces mas grande que el de v */&#13;
	public static int tree[];&#13;
	/* Array donde se guardan los valores */&#13;
	public static int v[];&#13;
&#13;
	void init(int node, int a, int b) {&#13;
		&#13;
		if (a == b) {&#13;
			tree[node] = v[a];&#13;
			return;&#13;
		}&#13;
		init(2*node+1, a, (a + b)/2);&#13;
		init(2*node+2, (a+b)/2+1, b);&#13;
		tree[node] = tree[2*node+1] + tree[2*node+2];&#13;
	}&#13;
&#13;
	int query(int node, int a, int b, int p, int q) {&#13;
		if (q &lt; a || b &lt; p) return 0; // return 0 for sum, 1 for product&#13;
		if (p &lt;= a &amp;&amp; b &lt;= q) return tree[node];&#13;
		return query(2*node+1, a, (a+b)/2, p, q) + query(2*node+2, (a+b)/2+1, b, p, q);&#13;
	}&#13;
&#13;
	void update(int node, int a, int b, int p, int val) {&#13;
		if (p &lt; a || b &lt; p) return;&#13;
		if (a == b) {&#13;
			tree[node] = val;&#13;
			return;&#13;
		}&#13;
		update(2*node+1, a, (a+b)/2, p, val);&#13;
		update(2*node+2, (a+b)/2+1, b, p, val);&#13;
		tree[node] = tree[2*node+1] + tree[2*node+2];&#13;
	}</template></templates>