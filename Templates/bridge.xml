<?xml version="1.0" encoding="UTF-8" standalone="no"?><templates><template autoinsert="true" context="java" deleted="false" description="Articulation Point And Bridge" enabled="true" name="bridge">	/*&#13;
	 *&#13;
	 *  *********************************&#13;
	 *  * ARTICULATION POINT AND BRIDGE *&#13;
	 *  *********************************&#13;
	 *  &#13;
	 *  TEMPLATE: bridge&#13;
	 *&#13;
	 */&#13;
	&#13;
	&#13;
	public static int[] dfsNum;&#13;
	public static int[] dfsLow;&#13;
	public static int dfsCounter;&#13;
	public static int[] dfsParent;&#13;
	public static int dfsRoot;&#13;
	public static int rootChildren;&#13;
	public static boolean[] visit;&#13;
	public static boolean[] articulationVertex;&#13;
	public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph;&#13;
	&#13;
	/*&#13;
	 * num = Numero de Vertices&#13;
	 */&#13;
	public static void init(int num) {&#13;
		dfsLow = new int[num];&#13;
		dfsNum = new int[num];&#13;
		visit = new boolean[num];&#13;
		articulationVertex = new boolean[num];&#13;
		dfsParent = new int[num];&#13;
		dfsCounter=0;&#13;
		dfsRoot=0;&#13;
		rootChildren=0;&#13;
		// cambiar dependiendo del indice&#13;
		for(int i=0; i&lt;num; i++) {&#13;
			graph.add(new ArrayList&lt;Integer&gt;());&#13;
		}&#13;
	}&#13;
	&#13;
	public static void articulationPointAndBridge(int u) {&#13;
		dfsCounter++;&#13;
		dfsNum[u]=dfsCounter;&#13;
		dfsLow[u]=dfsCounter;&#13;
		visit[u]=true;&#13;
		for(Integer v: graph.get(u)) {&#13;
			if(!visit[v]) {&#13;
				dfsParent[v]=u;&#13;
				if(u==dfsRoot)&#13;
					rootChildren++;&#13;
				&#13;
				articulationPointAndBridge(v);&#13;
				&#13;
				/*&#13;
				 * Verifica si es articulacion&#13;
				 */&#13;
				if(dfsLow[v] &gt;= dfsNum[u]) {&#13;
					articulationVertex[u] = true;&#13;
				}&#13;
				/*&#13;
				 * Verifica si es un puente&#13;
				 */&#13;
				if(dfsLow[v] &gt; dfsNum[u]) {&#13;
					//System.out.printf(" Edge (%d, %d) is a bridge\n", u, v);&#13;
				}&#13;
				dfsLow[u] = Math.min(dfsLow[u], dfsLow[v]);	&#13;
			}&#13;
			else if(v!=dfsParent[u]) {&#13;
				dfsLow[u] = Math.min(dfsLow[u], dfsNum[v]);	&#13;
			}&#13;
		}&#13;
	}&#13;
	&#13;
&#13;
	public static void findArticulationPointAndBridge() {&#13;
		// cambiar dependiendo del indice&#13;
		for(int i=0; i&lt;graph.size(); i++) {&#13;
			if(!visit[i]) {&#13;
				dfsRoot = i;&#13;
				rootChildren=0;&#13;
				articulationPointAndBridge(dfsRoot);&#13;
				articulationVertex[dfsRoot] = (rootChildren&gt;1);&#13;
			}&#13;
		}&#13;
	}</template></templates>